"""
This script analyze the simulations generated by mc_get_spectra.py
it estimates block numerical covariances from the simulations
"""


from pspy import pspy_utils, so_dict, so_spectra
from pspipe_utils import pspipe_list
import numpy as np
import sys

d = so_dict.so_dict()
d.read_from_file(sys.argv[1])

type = d["type"]
surveys = d["surveys"]
iStart = d["iStart"]
iStop = d["iStop"]

spec_dir = "sim_spectra"
cov_dir = "covariances"

pspy_utils.create_directory(cov_dir)

spectra = ["TT", "TE", "TB", "ET", "BT", "EE", "EB", "BE", "BB"]

spec_list = pspipe_list.get_spec_name_list(d, char="_")

for sid1, spec1 in enumerate(spec_list):
    for sid2, spec2 in enumerate(spec_list):
        if sid1 > sid2 : continue
        na, nb = spec1.split("x")
        nc, nd = spec2.split("x")
        
        ps_list_ab = []
        ps_list_cd = []
        for iii in range(iStart, iStop):
            spec_name_cross_ab = f"{type}_{na}x{nb}_cross_%05d" % iii
            spec_name_cross_cd = f"{type}_{nc}x{nd}_cross_%05d" % iii
        
            lb, ps_ab = so_spectra.read_ps(spec_dir + f"/{spec_name_cross_ab}.dat", spectra=spectra)
            lb, ps_cd = so_spectra.read_ps(spec_dir + f"/{spec_name_cross_cd}.dat", spectra=spectra)
    
            vec_ab = []
            vec_cd = []
            for spec in ["TT", "TE", "ET", "EE"]:
                vec_ab = np.append(vec_ab, ps_ab[spec])
                vec_cd = np.append(vec_cd, ps_cd[spec])
    
            ps_list_ab += [vec_ab]
            ps_list_cd += [vec_cd]

        cov_mc = 0
        for iii in range(iStart, iStop):
            cov_mc += np.outer(ps_list_ab[iii], ps_list_cd[iii])

        cov_mc = cov_mc / (iStop-iStart) - np.outer(np.mean(ps_list_ab, axis=0), np.mean(ps_list_cd, axis=0))

        np.save(f"{cov_dir}/mc_cov_{na}x{nb}_{nc}x{nd}.npy", cov_mc)


